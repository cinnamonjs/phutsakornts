import {
  createInstance
} from "./chunk-G2WEWIRJ.js";
import "./chunk-RDFXPUXV.js";
import {
  unstable_createContext
} from "./chunk-EU3FODI4.js";
import "./chunk-3NJ7IOTF.js";
import "./chunk-GN4BPQMF.js";
import {
  __publicField
} from "./chunk-EQCVQC35.js";

// node_modules/remix-i18next/build/lib/format-language-string.js
function formatLanguageString(language) {
  let parts = [language.code];
  if (language.script)
    parts.push(language.script);
  if (language.region)
    parts.push(language.region);
  return parts.join("-");
}

// node_modules/remix-i18next/build/lib/parser.js
var REGEX = /[ ]*((([a-zA-Z]+(-[a-zA-Z0-9]+){0,2})|\*)(;[ ]*q=[0-1](\.[0-9]+)?[ ]*)?)*/g;
function isString(value) {
  return typeof value === "string";
}
function parse(acceptLanguage) {
  var _a;
  let strings = (acceptLanguage || "").match(REGEX);
  if (!strings)
    throw new Error("Invalid Accept-Language header");
  let languages = [];
  for (let m of strings) {
    if (!m)
      continue;
    m = m.trim();
    let bits = m.split(";");
    let ietf = ((_a = bits[0]) == null ? void 0 : _a.split("-")) ?? [];
    let hasScript = ietf.length === 3;
    languages.push({
      // biome-ignore lint/style/noNonNullAssertion: We know this is not null
      code: ietf[0],
      script: hasScript ? ietf[1] : null,
      region: hasScript ? ietf[2] : ietf[1],
      quality: bits[1] ? (
        // biome-ignore lint/style/noNonNullAssertion: We know this is not null
        Number.parseFloat(bits[1].split("=")[1]) ?? 1
      ) : 1
    });
  }
  return languages.sort((a, b) => b.quality - a.quality);
}
function pick(supportedLanguages, acceptLanguage, options = { loose: false }) {
  var _a;
  if (!supportedLanguages || !supportedLanguages.length || !acceptLanguage) {
    return null;
  }
  let parsedAcceptLanguage = isString(acceptLanguage) ? parse(acceptLanguage) : acceptLanguage;
  let supported = supportedLanguages.map((support) => {
    let bits = support.split("-");
    let hasScript = bits.length === 3;
    return {
      // biome-ignore lint/style/noNonNullAssertion: We know this is not null
      code: bits[0],
      script: hasScript ? bits[1] : null,
      region: (hasScript ? bits[2] : bits[1]) ?? void 0
    };
  });
  for (let lang of parsedAcceptLanguage) {
    if (!lang)
      continue;
    let langCode = lang.code.toLowerCase();
    let langRegion = lang.region ? lang.region.toLowerCase() : lang.region;
    let langScript = lang.script ? lang.script.toLowerCase() : lang.script;
    for (let supportedLanguage of supported) {
      let supportedCode = ((_a = supportedLanguage.code) == null ? void 0 : _a.toLowerCase()) ?? "";
      if (langCode !== supportedCode)
        continue;
      let supportedScript = supportedLanguage.script ? supportedLanguage.script.toLowerCase() : supportedLanguage.script;
      let supportedRegion = supportedLanguage.region ? supportedLanguage.region.toLowerCase() : supportedLanguage.region;
      if (langCode === supportedCode && ((options == null ? void 0 : options.loose) || !langScript || langScript === supportedScript) && ((options == null ? void 0 : options.loose) || !langRegion || langRegion === supportedRegion)) {
        return formatLanguageString(supportedLanguage);
      }
    }
  }
  return null;
}

// node_modules/remix-i18next/build/lib/get-client-locales.js
function getClientLocales(requestOrHeaders) {
  let headers = getHeaders(requestOrHeaders);
  let acceptLanguage = headers.get("Accept-Language");
  if (!acceptLanguage)
    return void 0;
  let parsedLocales = parse(acceptLanguage).filter((lang) => lang.code !== "*").map(formatLanguageString);
  let validLocales = [];
  for (let locale2 of parsedLocales) {
    try {
      new Intl.Locale(locale2);
      validLocales.push(locale2);
    } catch {
    }
  }
  let locale = pick(Intl.DateTimeFormat.supportedLocalesOf(validLocales), acceptLanguage);
  return locale ?? void 0;
}
function getHeaders(requestOrHeaders) {
  if (requestOrHeaders instanceof Request)
    return requestOrHeaders.headers;
  return requestOrHeaders;
}

// node_modules/remix-i18next/build/lib/language-detector.js
var LanguageDetector = class {
  constructor(options) {
    __publicField(this, "options");
    this.options = options;
    this.isSessionOnly(options);
    this.isCookieOnly(options);
  }
  isSessionOnly(options) {
    var _a;
    if (((_a = options.order) == null ? void 0 : _a.length) === 1 && options.order[0] === "session" && !options.sessionStorage) {
      throw new Error("You need a sessionStorage if you want to only get the locale from the session");
    }
  }
  isCookieOnly(options) {
    var _a;
    if (((_a = options.order) == null ? void 0 : _a.length) === 1 && options.order[0] === "cookie" && !options.cookie) {
      throw new Error("You need a cookie if you want to only get the locale from the cookie");
    }
  }
  async detect(request) {
    let order = this.options.order ?? this.defaultOrder;
    for (let method of order) {
      let locale = null;
      if (method === "searchParams") {
        locale = this.fromSearchParams(request);
      }
      if (method === "cookie") {
        locale = await this.fromCookie(request);
      }
      if (method === "session") {
        locale = await this.fromSessionStorage(request);
      }
      if (method === "header") {
        locale = this.fromHeader(request);
      }
      if (method === "custom") {
        locale = await this.fromCustom(request);
      }
      if (locale)
        return locale;
    }
    return this.options.fallbackLanguage;
  }
  get defaultOrder() {
    let order = ["searchParams", "cookie", "session", "header"];
    if (this.options.findLocale)
      order.unshift("custom");
    return order;
  }
  fromSearchParams(request) {
    let url = new URL(request.url);
    if (!url.searchParams.has(this.options.searchParamKey ?? "lng")) {
      return null;
    }
    return this.fromSupported(url.searchParams.get(this.options.searchParamKey ?? "lng"));
  }
  async fromCookie(request) {
    if (!this.options.cookie)
      return null;
    let cookie = this.options.cookie;
    let lng = await cookie.parse(request.headers.get("Cookie"));
    if (typeof lng !== "string" || !lng)
      return null;
    return this.fromSupported(lng);
  }
  async fromSessionStorage(request) {
    if (!this.options.sessionStorage)
      return null;
    let session = await this.options.sessionStorage.getSession(request.headers.get("Cookie"));
    let lng = session.get(this.options.sessionKey ?? "lng");
    if (!lng)
      return null;
    return this.fromSupported(lng);
  }
  fromHeader(request) {
    let locales = getClientLocales(request);
    if (!locales)
      return null;
    if (Array.isArray(locales))
      return this.fromSupported(locales.join(","));
    return this.fromSupported(locales);
  }
  async fromCustom(request) {
    if (!this.options.findLocale) {
      throw new ReferenceError("You tried to find a locale using `findLocale` but it iss not defined. Change your order to not include `custom` or provide a findLocale functions.");
    }
    let locales = await this.options.findLocale(request);
    if (!locales)
      return null;
    if (Array.isArray(locales))
      return this.fromSupported(locales.join(","));
    return this.fromSupported(locales);
  }
  fromSupported(language) {
    return pick(this.options.supportedLanguages, language ?? this.options.fallbackLanguage, { loose: false }) || pick(this.options.supportedLanguages, language ?? this.options.fallbackLanguage, { loose: true });
  }
};

// node_modules/remix-i18next/build/middleware.js
function unstable_createI18nextMiddleware({ detection, i18next = {}, plugins = [] }) {
  let localeContext = unstable_createContext();
  let i18nextContext = unstable_createContext();
  let languageDetector = new LanguageDetector(detection);
  return [
    async function i18nextMiddleware({ request, context }, next) {
      let lng = await languageDetector.detect(request);
      context.set(localeContext, lng);
      let instance = createInstance(i18next);
      for (const plugin of plugins ?? [])
        instance.use(plugin);
      await instance.init({ lng });
      context.set(i18nextContext, instance);
      return await next();
    },
    (context) => context.get(localeContext),
    (context) => context.get(i18nextContext)
  ];
}
export {
  unstable_createI18nextMiddleware
};
//# sourceMappingURL=remix-i18next_middleware.js.map

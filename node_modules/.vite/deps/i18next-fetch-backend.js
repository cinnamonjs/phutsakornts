import {
  __publicField
} from "./chunk-EQCVQC35.js";

// node_modules/i18next-fetch-backend/index.js
var defaults = {
  loadPath: "/locales/{{lng}}/{{ns}}.json",
  addPath: "/locales/add/{{lng}}/{{ns}}",
  multiSeparator: "+",
  allowMultiLoading: false,
  fetch: typeof fetch === "undefined" ? void 0 : fetch,
  parse: JSON.parse,
  stringify: JSON.stringify,
  requestOptions: {}
};
var arrify = (val) => Array.isArray(val) ? val : [val];
var normalize = (funcOrVal, ...args) => typeof funcOrVal === "function" ? funcOrVal(...args) : funcOrVal;
var BackendError = class extends Error {
  constructor(message, retry = false) {
    super(message);
    __publicField(this, "retry", null);
    this.retry = retry;
  }
};
var Backend = class {
  constructor(services, options) {
    __publicField(this, "type", "backend");
    this.init(services, options);
  }
  init(services, options = {}) {
    this.services = services;
    this.options = {
      ...defaults,
      ...this.options,
      ...options
    };
  }
  getLoadPath(languages, namespaces) {
    return normalize(this.options.loadPath, languages, namespaces);
  }
  read(language, namespace, callback) {
    const loadPath = this.getLoadPath(language, namespace);
    const url = this.services.interpolator.interpolate(loadPath, { lng: language, ns: namespace });
    this.loadUrl(url, callback);
  }
  readMulti(languages, namespaces, callback) {
    const loadPath = this.getLoadPath(languages, namespaces);
    const { multiSeparator } = this.options;
    const url = this.services.interpolator.interpolate(loadPath, {
      lng: languages.join(multiSeparator),
      ns: namespaces.join(multiSeparator)
    });
    this.loadUrl(url, callback);
  }
  loadUrl(url, callback) {
    const { fetch: fetch2, requestOptions, parse } = this.options;
    fetch2(url, requestOptions).then((response) => {
      const { ok, status } = response;
      if (!ok) {
        const retry = status >= 500 && status < 600;
        throw new BackendError(`failed loading ${url}`, retry);
      }
      return response.text();
    }, () => {
      throw new BackendError(`failed loading ${url}`);
    }).then((data) => {
      try {
        return callback(null, parse(data, url));
      } catch {
        throw new BackendError(`failed parsing ${url} to json`, false);
      }
    }).catch((e) => {
      if (e instanceof BackendError) {
        callback(e.message, e.retry);
      }
    });
  }
  create(languages, namespace, key, fallbackValue) {
    const payload = {
      [key]: fallbackValue || ""
    };
    arrify(languages).forEach((lng) => {
      const {
        addPath,
        requestOptions,
        fetch: fetch2,
        stringify
      } = this.options;
      const url = this.services.interpolator.interpolate(addPath, { lng, ns: namespace });
      try {
        fetch2(url, {
          method: "POST",
          body: stringify(payload),
          ...requestOptions
        });
      } catch (e) {
        console.error(e);
      }
    });
  }
};
__publicField(Backend, "type", "backend");
export {
  Backend as default
};
//# sourceMappingURL=i18next-fetch-backend.js.map

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  denyImports: () => deny_imports_default,
  envOnlyMacros: () => envOnlyMacros
});
module.exports = __toCommonJS(src_exports);

// node_modules/.pnpm/tsup@8.0.1_postcss@8.4.32_typescript@5.4.5/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// package.json
var name = "vite-env-only";
var package_default = {
  name,
  version: "3.0.3",
  description: "Vite plugins for isolating server-only and client-only code",
  keywords: [
    "vite-plugin",
    "env",
    "only",
    "client",
    "server",
    "macro",
    "deny",
    "imports"
  ],
  repository: "pcattori/vite-env-only",
  author: "pcattori",
  license: "MIT",
  type: "module",
  exports: {
    ".": {
      import: "./dist/index.js",
      require: "./dist/index.cjs"
    },
    "./macros": {
      import: "./dist/macros.js",
      require: "./dist/macros.cjs"
    },
    "./package.json": "./package.json"
  },
  scripts: {
    typecheck: "tsc",
    build: "tsup",
    test: "vitest",
    changeset: "changeset"
  },
  packageManager: "pnpm@9.1.1",
  peerDependencies: {
    vite: "*"
  },
  devDependencies: {
    "@changesets/cli": "^2.27.2",
    "@types/babel__core": "^7.20.5",
    "@types/babel__generator": "^7.6.8",
    "@types/babel__traverse": "^7.20.5",
    "@types/micromatch": "^4.0.7",
    "@types/node": "^20.10.6",
    dedent: "^1.5.1",
    tsup: "^8.0.1",
    typescript: "^5.4.5",
    vite: "^5.0.11",
    vitest: "^1.1.2"
  },
  dependencies: {
    "@babel/core": "^7.23.7",
    "@babel/generator": "^7.23.6",
    "@babel/parser": "^7.23.6",
    "@babel/traverse": "^7.23.7",
    "@babel/types": "^7.23.6",
    "babel-dead-code-elimination": "^1.0.6",
    micromatch: "^4.0.5"
  },
  prettier: {
    semi: false
  },
  files: [
    "dist"
  ],
  release: {
    branches: [
      "main"
    ]
  }
};

// src/transform.ts
var babel = __toESM(require("@babel/core"), 1);

// src/babel.ts
var import_parser = require("@babel/parser");
var t = __toESM(require("@babel/types"), 1);
var import_node_module = require("module");
var require2 = (0, import_node_module.createRequire)(importMetaUrl);
var _traverse = require2("@babel/traverse");
var traverse = _traverse.default;
var _generate = require2("@babel/generator");
var generate = _generate.default;

// src/transform.ts
var import_babel_dead_code_elimination = require("babel-dead-code-elimination");
var macrosSpecifier = `${name}/macros`;
var isMacroBinding = (binding, macro) => {
  if (!t.isImportDeclaration(binding?.path.parent))
    return false;
  if (binding.path.parent.source.value !== macrosSpecifier)
    return false;
  if (!t.isImportSpecifier(binding?.path.node))
    return false;
  let { imported } = binding.path.node;
  if (!t.isIdentifier(imported))
    return false;
  if (imported.name !== macro)
    return false;
  return true;
};
var isMacro = (path2, macro) => {
  if (!t.isIdentifier(path2.node.callee))
    return false;
  let binding = path2.scope.getBinding(path2.node.callee.name);
  if (!binding)
    return false;
  if (!isMacroBinding(binding, macro))
    return false;
  if (path2.node.arguments.length !== 1) {
    throw path2.buildCodeFrameError(`'${macro}' must take exactly one argument`);
  }
  return true;
};
var transform = (code, id, options) => {
  let ast = (0, import_parser.parse)(code, { sourceType: "module" });
  new babel.File({ filename: void 0 }, { code, ast });
  const refs = (0, import_babel_dead_code_elimination.findReferencedIdentifiers)(ast);
  traverse(ast, {
    CallExpression(path2) {
      if (isMacro(path2, options.ssr ? "clientOnly$" : "serverOnly$")) {
        path2.replaceWith(t.identifier("undefined"));
      }
      if (isMacro(path2, options.ssr ? "serverOnly$" : "clientOnly$")) {
        let arg = path2.node.arguments[0];
        if (t.isExpression(arg)) {
          path2.replaceWith(arg);
        }
      }
    },
    // ensure that macros are not manipulated at runtime
    Identifier(path2) {
      if (t.isImportSpecifier(path2.parent))
        return;
      let binding = path2.scope.getBinding(path2.node.name);
      if (!binding)
        return;
      if (!isMacroBinding(binding, "serverOnly$") && !isMacroBinding(binding, "clientOnly$")) {
        return;
      }
      if (t.isCallExpression(path2.parent))
        return;
      throw path2.buildCodeFrameError(
        `'${path2.node.name}' macro cannot be manipulated at runtime as it must be statically analyzable`
      );
    },
    // ensure that macros are not imported via namespace
    ImportDeclaration(path2) {
      if (path2.node.source.value !== macrosSpecifier)
        return;
      path2.node.specifiers.forEach((specifier, i) => {
        if (t.isImportNamespaceSpecifier(specifier)) {
          const subpath = path2.get(`specifiers.${i}`);
          if (Array.isArray(subpath))
            throw new Error("unreachable");
          throw subpath.buildCodeFrameError(
            `Namespace import is not supported by '${macrosSpecifier}'`
          );
        }
      });
    }
  });
  (0, import_babel_dead_code_elimination.deadCodeElimination)(ast, refs);
  return generate(ast, { sourceMaps: true, sourceFileName: id }, code);
};

// src/deny-imports.ts
var import_node_path = __toESM(require("path"), 1);
var import_vite = require("vite");

// src/pattern.ts
var import_micromatch = __toESM(require("micromatch"), 1);
function findMatch(id, patterns = []) {
  for (let pattern of patterns) {
    let matchGlob = typeof pattern === "string" && import_micromatch.default.isMatch(id, pattern);
    let matchRegex = pattern instanceof RegExp && id.match(pattern);
    if (matchGlob || matchRegex)
      return pattern;
  }
  return null;
}

// src/deny-imports.ts
function deny_imports_default(options) {
  let denySpecifiers = {};
  let denyFiles = {};
  for (let [env, { specifiers, files }] of Object.entries(options)) {
    denySpecifiers[env] = specifiers;
    denyFiles[env] = files;
  }
  return [denyImportSpecifiers(denySpecifiers), denyImportFiles(denyFiles)];
}
function denyImportSpecifiers(denySpecifiers) {
  let root;
  let command;
  return {
    name: "deny-imports/specifiers",
    enforce: "pre",
    configResolved(config) {
      root = config.root;
      command = config.command;
    },
    resolveId(id, importer, options) {
      if (!importer)
        return;
      let env = options?.ssr ? "server" : "client";
      let denialPattern = findMatch(id, denySpecifiers[env]);
      if (denialPattern) {
        let message = [
          `[${package_default.name}] Import denied`,
          ` - Denied by specifier pattern: ${denialPattern}`,
          ` - Importer: ${normalizeRelativePath(root, importer)}`,
          ` - Import: "${id}"`,
          ` - Environment: ${env}`
        ].join("\n");
        throw Error(message);
      }
    }
  };
}
function denyImportFiles(denyFiles) {
  let root;
  let command;
  let name2 = "deny-imports/files";
  return {
    name: name2,
    enforce: "pre",
    configResolved(config) {
      root = config.root;
      command = config.command;
    },
    async resolveId(id, importer, options) {
      if (command !== "build" && importer?.endsWith(".html"))
        return;
      let isResolving = options?.custom?.[name2] ?? false;
      if (isResolving)
        return;
      options.custom = {
        ...options.custom,
        [name2]: true
      };
      let resolvedId = (await this.resolve(id, importer, options))?.id;
      if (!resolvedId || !import_node_path.default.isAbsolute(resolvedId))
        return;
      let relativePath = normalizeRelativePath(root, resolvedId);
      let env = options?.ssr ? "server" : "client";
      let denialPattern = findMatch(relativePath, denyFiles[env]);
      if (denialPattern) {
        let message = [
          `[${package_default.name}] Import denied`,
          ` - Denied by file pattern: ${denialPattern}`,
          ...importer ? [` - Importer: ${normalizeRelativePath(root, importer)}`] : [],
          ` - Import: "${id}"`,
          ` - Resolved: ${relativePath}`,
          ` - Environment: ${env}`
        ].join("\n");
        throw Error(message);
      }
    }
  };
}
function normalizeRelativePath(root, filePath) {
  return (0, import_vite.normalizePath)(import_node_path.default.relative(root, filePath));
}

// src/index.ts
function envOnlyMacros() {
  return [
    {
      name: "env-only-macros",
      async transform(code, id, options) {
        if (!code.includes(name))
          return;
        return transform(code, id, { ssr: options?.ssr === true });
      }
    }
  ];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  denyImports,
  envOnlyMacros
});

import {
  name,
  package_default
} from "./chunk-IBL4GUA3.js";

// src/transform.ts
import * as babel from "@babel/core";

// src/babel.ts
import { parse } from "@babel/parser";
import * as t from "@babel/types";
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);
var _traverse = require2("@babel/traverse");
var traverse = _traverse.default;
var _generate = require2("@babel/generator");
var generate = _generate.default;

// src/transform.ts
import {
  deadCodeElimination,
  findReferencedIdentifiers
} from "babel-dead-code-elimination";
var macrosSpecifier = `${name}/macros`;
var isMacroBinding = (binding, macro) => {
  if (!t.isImportDeclaration(binding?.path.parent))
    return false;
  if (binding.path.parent.source.value !== macrosSpecifier)
    return false;
  if (!t.isImportSpecifier(binding?.path.node))
    return false;
  let { imported } = binding.path.node;
  if (!t.isIdentifier(imported))
    return false;
  if (imported.name !== macro)
    return false;
  return true;
};
var isMacro = (path2, macro) => {
  if (!t.isIdentifier(path2.node.callee))
    return false;
  let binding = path2.scope.getBinding(path2.node.callee.name);
  if (!binding)
    return false;
  if (!isMacroBinding(binding, macro))
    return false;
  if (path2.node.arguments.length !== 1) {
    throw path2.buildCodeFrameError(`'${macro}' must take exactly one argument`);
  }
  return true;
};
var transform = (code, id, options) => {
  let ast = parse(code, { sourceType: "module" });
  new babel.File({ filename: void 0 }, { code, ast });
  const refs = findReferencedIdentifiers(ast);
  traverse(ast, {
    CallExpression(path2) {
      if (isMacro(path2, options.ssr ? "clientOnly$" : "serverOnly$")) {
        path2.replaceWith(t.identifier("undefined"));
      }
      if (isMacro(path2, options.ssr ? "serverOnly$" : "clientOnly$")) {
        let arg = path2.node.arguments[0];
        if (t.isExpression(arg)) {
          path2.replaceWith(arg);
        }
      }
    },
    // ensure that macros are not manipulated at runtime
    Identifier(path2) {
      if (t.isImportSpecifier(path2.parent))
        return;
      let binding = path2.scope.getBinding(path2.node.name);
      if (!binding)
        return;
      if (!isMacroBinding(binding, "serverOnly$") && !isMacroBinding(binding, "clientOnly$")) {
        return;
      }
      if (t.isCallExpression(path2.parent))
        return;
      throw path2.buildCodeFrameError(
        `'${path2.node.name}' macro cannot be manipulated at runtime as it must be statically analyzable`
      );
    },
    // ensure that macros are not imported via namespace
    ImportDeclaration(path2) {
      if (path2.node.source.value !== macrosSpecifier)
        return;
      path2.node.specifiers.forEach((specifier, i) => {
        if (t.isImportNamespaceSpecifier(specifier)) {
          const subpath = path2.get(`specifiers.${i}`);
          if (Array.isArray(subpath))
            throw new Error("unreachable");
          throw subpath.buildCodeFrameError(
            `Namespace import is not supported by '${macrosSpecifier}'`
          );
        }
      });
    }
  });
  deadCodeElimination(ast, refs);
  return generate(ast, { sourceMaps: true, sourceFileName: id }, code);
};

// src/deny-imports.ts
import path from "path";
import { normalizePath } from "vite";

// src/pattern.ts
import micromatch from "micromatch";
function findMatch(id, patterns = []) {
  for (let pattern of patterns) {
    let matchGlob = typeof pattern === "string" && micromatch.isMatch(id, pattern);
    let matchRegex = pattern instanceof RegExp && id.match(pattern);
    if (matchGlob || matchRegex)
      return pattern;
  }
  return null;
}

// src/deny-imports.ts
function deny_imports_default(options) {
  let denySpecifiers = {};
  let denyFiles = {};
  for (let [env, { specifiers, files }] of Object.entries(options)) {
    denySpecifiers[env] = specifiers;
    denyFiles[env] = files;
  }
  return [denyImportSpecifiers(denySpecifiers), denyImportFiles(denyFiles)];
}
function denyImportSpecifiers(denySpecifiers) {
  let root;
  let command;
  return {
    name: "deny-imports/specifiers",
    enforce: "pre",
    configResolved(config) {
      root = config.root;
      command = config.command;
    },
    resolveId(id, importer, options) {
      if (!importer)
        return;
      let env = options?.ssr ? "server" : "client";
      let denialPattern = findMatch(id, denySpecifiers[env]);
      if (denialPattern) {
        let message = [
          `[${package_default.name}] Import denied`,
          ` - Denied by specifier pattern: ${denialPattern}`,
          ` - Importer: ${normalizeRelativePath(root, importer)}`,
          ` - Import: "${id}"`,
          ` - Environment: ${env}`
        ].join("\n");
        throw Error(message);
      }
    }
  };
}
function denyImportFiles(denyFiles) {
  let root;
  let command;
  let name2 = "deny-imports/files";
  return {
    name: name2,
    enforce: "pre",
    configResolved(config) {
      root = config.root;
      command = config.command;
    },
    async resolveId(id, importer, options) {
      if (command !== "build" && importer?.endsWith(".html"))
        return;
      let isResolving = options?.custom?.[name2] ?? false;
      if (isResolving)
        return;
      options.custom = {
        ...options.custom,
        [name2]: true
      };
      let resolvedId = (await this.resolve(id, importer, options))?.id;
      if (!resolvedId || !path.isAbsolute(resolvedId))
        return;
      let relativePath = normalizeRelativePath(root, resolvedId);
      let env = options?.ssr ? "server" : "client";
      let denialPattern = findMatch(relativePath, denyFiles[env]);
      if (denialPattern) {
        let message = [
          `[${package_default.name}] Import denied`,
          ` - Denied by file pattern: ${denialPattern}`,
          ...importer ? [` - Importer: ${normalizeRelativePath(root, importer)}`] : [],
          ` - Import: "${id}"`,
          ` - Resolved: ${relativePath}`,
          ` - Environment: ${env}`
        ].join("\n");
        throw Error(message);
      }
    }
  };
}
function normalizeRelativePath(root, filePath) {
  return normalizePath(path.relative(root, filePath));
}

// src/index.ts
function envOnlyMacros() {
  return [
    {
      name: "env-only-macros",
      async transform(code, id, options) {
        if (!code.includes(name))
          return;
        return transform(code, id, { ssr: options?.ssr === true });
      }
    }
  ];
}
export {
  deny_imports_default as denyImports,
  envOnlyMacros
};
